# Configuration for blocksworld planner evolution
max_iterations: 100
checkpoint_interval: 10

# LLM configuration
llm:
  primary_model: "gemini-2.5-pro"
  primary_model_weight: 0.7
  secondary_model: "gemini-2.5-flash"
  secondary_model_weight: 0.3
  api_base: "https://generativelanguage.googleapis.com/v1beta/openai/"
  temperature: 0.7
  max_tokens: 16000
  timeout: 120

# Prompt configuration
prompt:
  system_message: |
    You are an expert in AI planning and search algorithms. Your task is to improve a blocksworld planner.

    The current planner uses pure random search - it randomly tries action sequences until finding a solution.
    This is extremely inefficient for problems with 8+ blocks.

    Your goal is to evolve better planning strategies. Consider these approaches:

    **Search Strategies:**
    - Breadth-first search (BFS) - systematically explore state space
    - Depth-first search with backtracking
    - A* search with heuristics
    - Hill climbing with random restarts
    - Iterative deepening

    **Heuristics for Blocksworld:**
    - Count blocks not in goal position
    - Check if blocks are "well-placed" (in correct relative order)
    - Prioritize clearing blocks that need to move
    - Avoid breaking up correct partial stacks

    **Efficiency Improvements:**
    - Track visited states to avoid cycles
    - Use priority queues for informed search
    - Prune obviously bad states early
    - Recognize when partial progress is made

    The planner must:
    - Handle 6-10 block problems within 30 second timeout
    - Find solutions (correctness first, then optimize plan length)
    - Work with the existing BlocksworldSimulator interface

    Focus on algorithmic improvements. Small wins like better state exploration
    or simple heuristics can dramatically outperform random search.

# Database configuration
database:
  population_size: 100
  archive_size: 30
  num_islands: 5
  elite_selection_ratio: 0.2
  exploitation_ratio: 0.7
  migration_interval: 20
  migration_rate: 0.1

# Evaluator configuration
evaluator:
  timeout: 1000  # High safety net - per-problem timeouts do the real work (5s Ã— 95 problems = 475s max)
  cascade_evaluation: false  # Single-stage evaluation with early termination
  parallel_evaluations: 3

# Evolution settings
diff_based_evolution: true
max_code_length: 30000
