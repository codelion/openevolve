# Example Configuration for Hierarchical Abstraction Layer Evolution
# This demonstrates how to enable and configure the hierarchical system

# General settings
max_iterations: 1000
checkpoint_interval: 100
log_level: INFO
random_seed: 42

# LLM Configuration
llm:
  api_base: "https://api.openai.com/v1"
  temperature: 0.7
  max_tokens: 4096

  # Base models for standard evolution (Tier 1)
  models:
    - name: "gpt-4o"
      weight: 1.0

# Database Configuration
database:
  population_size: 1000
  archive_size: 100
  num_islands: 5
  exploration_ratio: 0.2
  exploitation_ratio: 0.7

  # MAP-Elites feature dimensions
  feature_dimensions:
    - "complexity"
    - "diversity"
  feature_bins: 10

  # Migration settings
  migration_interval: 50
  migration_rate: 0.1

# Evaluator Configuration
evaluator:
  timeout: 300
  cascade_evaluation: true
  enable_artifacts: true

# Hierarchical Evolution Configuration
hierarchical:
  # Enable hierarchical abstraction layers
  enabled: true

  # Model Tiers - Use different models for different abstraction layers
  # Tier 0: Fast models for L1 local search (high frequency, simple changes)
  tier0_models:
    - name: "gpt-4o-mini"
      weight: 1.0
      temperature: 0.8
      max_tokens: 2048

  # Tier 1: Standard models for L2 implementation patterns
  tier1_models:
    - name: "gpt-4o"
      weight: 1.0
      temperature: 0.7
      max_tokens: 4096

  # Tier 2: Strong models for L3 architecture and L4 paradigms
  tier2_models:
    - name: "gpt-4o"
      weight: 1.0
      temperature: 0.6
      max_tokens: 8192

  # Tier 3: Reasoning models for L4/L5 strategic pivots
  # Use reasoning models like o1 or o3-mini when available
  tier3_models:
    - name: "gpt-4o"  # Fallback - replace with o1/o3-mini when available
      weight: 1.0
      temperature: 0.5
      max_tokens: 16384
      # reasoning_effort: "high"  # Uncomment for reasoning models

  # Layer Transition Triggers
  # Controls when each layer is activated based on plateau detection
  l2_plateau_iterations: 5    # Evolve L2 (patterns) when L1 (code) plateaus for 5 iterations
  l3_plateau_iterations: 20   # Evolve L3 (architecture) when L2 plateaus for 20 iterations
  l4_plateau_iterations: 100  # Evolve L4 (paradigms) when L3 plateaus for 100 iterations
  l5_plateau_iterations: 500  # Evolve L5 (meta-principles) when L4 plateaus for 500 iterations

  # Minimum score improvement to count as progress
  min_improvement_threshold: 0.001

  # Insight Extraction
  enable_insight_extraction: true
  insight_extraction_interval: 100  # Extract insights every 100 generations
  use_llm_for_insights: false  # Use LLM for deeper insight analysis (more expensive)

  # Context Compilation Settings
  context_max_tokens: 50000  # Maximum tokens for context
  recent_weight: 0.7  # Weight for recent solutions vs historical
  local_weight: 0.6   # Weight for same branch vs cross-branch
  success_weight: 0.8 # Weight for successes vs failures

  # Evolutionary Memory Graph (EMG)
  emg_enabled: true
  # emg_save_path: "path/to/save/emg"  # Optional: defaults to output_dir/emg

  # Phase Detection
  exploration_phase_threshold: 0.3  # Success rate below 30% triggers exploration phase
  crisis_exhausted_layers: 2  # 2+ exhausted layers triggers crisis mode

# Evolution Settings
diff_based_evolution: true
max_code_length: 10000

# Early Stopping
early_stopping_patience: 100
convergence_threshold: 0.001
early_stopping_metric: "combined_score"
